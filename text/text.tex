\section{Введение}
Цифровое изображение имеет конечное количество пикселей. Количество этих пикселей деленное на единицу площади называется
разрешением цифрового изображения.

Для анализа и обработки изображений в большинстве случаев используются изображения высокого разрешения, так как они
позволяют увидеть детали, которые не различимы, или плохо различимы на изображениях с низким разрешением. Многие задачи
компьютерного зрения изначально полагаются на то, что изображение на входе в хорошем разрешение. Например, алгоритмы
распознавания автомобильного номера будут работать намного устойчивее, если на вход они будут получать изображение с
высоким разрешением. С первого взгляда,
задача увеличения разрешения чисто аппаратная -- чтобы увеличить разрешение необходимо просто взять фотоаппарат с
большей разрешающей способностью. Но часто уже имеется некоторая фотография или набор фотографий, и нет возможности
повторно произвести съемку. Примером может послужить низкокачественные картинки с изображений камер наблюдения. В этом
случае уместно использовать программные алгоритмы повышения разрешения (Super-resolution методы).  Эти алгоритмы
используют некоторое дополнительное знание о изображении для качественного повышения разрешения. Примером
дополнительных знаний может послужить информация о том, как двигался объект во время съемки, или оптические параметры
камеры. Зная эти параметры можно алгоритмическим путем получить более качественное изображение.

В этой работе рассмотрены два алгоритма для повышения разрешения на примере автомобильных номеров.

\section{Обзор существующих алгоритмов} Классические алгоритмы Super-Resolution делятся на четыре
категории.  Существует несколько обзорных статей по
этим алгоритмам \cite{ParkS.C.2003,tian2011survey}

\subsection{Обучаемые алгоритмы}
Обучаемые алгоритмы используют для восстановления изображений используют знание о том, что в действительности изображено
на картинке. Такие алгоритмы хорошо подходят для повышения разрешения однотипных изображений, таких как лица или
автомобильные номера.

\subsection{Интерполяционные} Подход интерполяции наиболее интуитивно понятный метод решения задачи SR. Решение задачи,
в общем случае, разбивается на три шага: определение относительного движения (Motion estimation) для каждого
изображения, интерполяция LR изображений на HR сетку, удаление смазывания и шума для полученного HR изображения.

\subsubsection{Метод ближайшего соседа}
При печати этого текста компьютером тоже была решена задача повышения разрешения, т.к. принтер печатает изображения с
намного более большим разрешением, чем была исходная картинка. В этом случае, задача решается не самым лучшим образом --
компьютер просто просчитывает недостающие точки, используя значения пикселя изображения, который находится ближе всего.
Такая примитивная интерполяция называется <<метод ближайшего соседа>>.

\subsubsection{Билинейная интерполяция}
Билинейная интерполяция чуть более продвинутый метод интерполяции. Для интерполяции используется взвешенные суммы
линейных интерполяций по вертикальной и горизонтальной оси. Более подробное описание и формулу билинейной интерполяции
можно найти в \cite[стр. 64]{gonzalez2002woods}.

\subsubsection{Бикубическая интерполяция}
Бикубическая интерполяция обладает одним из лучших сочетаний качества и скорости.  Бикубическая
интерполяция являеется обобщением интерполяции кубическими сплайнами на двумерный случай. Алгоритм кубической
интерполяции реализован во многих редакторах цифровых изображений. В нашей статье мы будем считать алгоритм бикубической
интерполяции отправной точкой. По сравнение результатов бикубической интерполяции и предложенного метода можно судить
том, улучшает алгоритм изображение, или нет. Более подробно алгоритм описан в  \cite{keys1981cubic}.

\subsection{Спектральное представление}
В алгоритмах этого класса используется разложение изображения в некоторый другой
базис (примером может являться двумерное дискретное преобразование Фурье, или дискретное косинусное преобразование), и
обратное к нему.  Этот метод удобен тем, что мелкие детали соответствуют высоко частотным компонентам базиса, и за счет
этого становится возможным восстанавливать мелкие детали изображения, которые возможно получить за счет интерполяции с
нескольких LR изображений. \cite{danielyan2012bm3d, Zemlyansky2012}

\subsection{Регуляризация} Алгоритмы с использованием регуляризации используют некоторые знания о природе изображения.
Например, в алгоритме MAP(maximum a posteriori) используют предположение о вероятности распределений точек. \cite{suresh2007superresolution,yuan2008fast}

\section{Постановка задачи}
Для рассуждений необходимо некоторым образом формально записать то, с чем имеем дело. Для этого понадобиться ввести
несколько дополнительных понятий.

\subsection{Метрика PSNR}
Для того, чтобы сравнивать несколько алгоритмов повышения разрешения необходимо ввести какую-нибудь количественную
метрику. Чтобы иметь возможность посчитать метрику, необходимо знать истинное изображение, то есть такое изображение,
которое должен выдать идеальный алгоритм повышения разрешения. Очевидно, что создать идеальный алгоритм невозможно --
это отображение из $\mathbb{N}^{n \cdot m } \to \mathbb{N}^{nk \cdot mk}, k \ge 2$. Знание истинного изображения
несколько выходит за рамки поставленной во введении задачи -- в реальных условиях истинное изображение будет неизвестно.
Для тестирования алгоритмов были использована стандартная модель( \cite{suresh2007superresolution,yuan2008fast, danielyan2012bm3d}) получения изображений низкого разрешения из высокого.

Пусть $x$ -- истинное изображение, $\tilde{x}$ -- найденное изображение из изображений низкого разрешения. Посчитаем
среднеквадратичную ошибку между пикселями этих изображений.

$$ \mathrm{MSE}(\tilde{x},x) = \frac{1}{m\,n}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1} [\tilde{x}(i,j) - x(i,j)]^2$$

И выразим отношение $\mathrm{MAX}_I$ (максимальное значение яркости изображения) к среднеквадратичной ошибке в
децибелах
$\mathrm{PSNR}(\tilde{x},x)$.
$$ \mathrm{PSNR}(\tilde{x},x) = 10 \cdot \log_{10} \left( \frac{\mathrm{MAX}_I^2}{\mathrm{MSE}(\tilde{x},x)} \right) $$

Это и будет нашей метрикой. Задачей будет достигнуть максимального значения PSNR из имеющихся данных.

\subsection{Интерполяция}
Одним из наиболее известных способов повышения разрешения является интерполяция. Для любого изображения можно бесконечно
повышать разрешения, просто добавляя дополнительные значения между пикселями исходного изображения. Однако, такое
повышение разрешения не всегда дает хорошие результаты. Поскольку значение PSNR лишь показывает разницу между двумя
изображениями, то нет возможности численно оценить насколько алгоритм Super-resolution хорошо справился с задачей. Но
если сравнивать этот же алгоритм со значением полученные каким-либо методом интерполяции то наглядно видно, где алгоритм
справляется хорошо, а где плохо.

\subsection{Изображения как векторы}
Для возможности записывать все операции над изображением как матричное умножение, будем считать, что изображение
высокого разрешения, которое мы хотим восстановить $x$ размера $L_{1}N_{1}\times L_{2}N_{2}$ записано в виде вектора в
виде вектора $x=[x_{1},x_{2},\dots,x_{N}]^{T}$, где $N=L_{1}{N_{1}\times L_{2}N_{2}}$. Другими словами, изображение $x$
это то изображение, которое мы бы получили, если бы использовали матрицу фотоаппарата с более большим разрешением.

\subsection{Задача Super-Resolution}
$$y_r = D H_r W_r x +\sigma_{k}\epsilon,~ ~ ~ 1 \leq r \leq m$$
 где:
 \begin{itemize}
   \item $x$ оригинальное изображение
   \item $y_r$ наблюдение $r$
   \item $D$ матрица понижение разрешения
   \item $W_r$ матрица геометрического искажения
   \item $H_r$ матрица размытия наблюдения $r$
   \item $\sigma_{k}\epsilon$ шум наблюдения $r$
   \item $m$ количество наблюдений
 \end{itemize}
 Задача найти
 $$ \tilde{x} = \underset{\hat{x}}{\operatorname{argmax}}~  PSNR(\hat{x},x)$$
для коллекции тестовых изображений $y_r$

\section{Используемые алгоритмы}
Для того, чтобы повысить разрешение автомобильного номера использовались два подхода: обучаемый \cite{yang2012coupled} и
интерполяционный с использованием регуляризации \cite{suresh2007superresolution}. Этот выбор основывался исходя из
природы изображения автомобильного номера.

\subsection{Обучаемый алгоритм на словарях}
\label{sr1}
В статье \cite{yang2012coupled} авторы предлагают использовать для задачи повышения разрешения одного изображения
использовать пару связанных словарей $D_x$ и $D_y$ -- словари содержащие патчи из пространства изображений
с высоким и низким разрешением.

Алгоритм требует предварительного обучения нейронной сети. Для этого была создана база с изображениями автомобильных
номеров. Использовав авторскую реализацию алгоритма была обучена пара словарей для восстановления изображений.

Обоснованием, для применения этого метода были следующие:
\begin{itemize}
  \item Автомобильные номера содержат конечный набор патчей. Автомобильные номера очень похожи между собой. И явно
    видно, что между двумя изображениями автомобильных номеров есть общие кусочки изображения.
  \item Автомобильные номера имеют простую структуру -- у них нет сложных переходов, большиство смены цветов это просто
    переход от белого к черному.
\end{itemize}

\subsection{Алгоритм с использованием регуляризации}
\label{sr2}
В статье \cite{yuan2008fast} авторы предлагают улучшение алгоритма MAP для задачи повышение изображения. Изображение
моделируется как Марковская сеть и используется алгоритм итеративной оптимизации в сочетании с
регуляризатором для сохранения границ.

Прежде, чем говорить о самом алгоритме требуется сделать предварительный шаг -- установление движение (motion
estimation). Поскольку мы работаем в модели, то считается, что движение изображений относительно друг друга уже было
установлено некоторым другим алгоритмом.

Общий вид алгоритма следующий:
\begin{enumerate}
  %\item Найти целочисленный сдвиг изображений относительно первого. Эта задача решается испол
  \item посчитать среднее от выровненных и билинейно интерполированных изображений $X^{(0)}$. Будем называть полученные на этом
    шаге изображение <<начальным приближением>>
  \item положить $\gamma = 2v$, где $v$ -- максимальное значение градиента по осям $x$ и $y$ в начальном приближении
    $X^{(0)}$
  \item Do:
    \begin{enumerate}
      \item $X^{(n+1)} = X^{(n)} - \alpha\cdot\mathrm{grad}(X^{(N)}, \gamma) $
      \item $n=n+1$
      \item If $(\operatorname{norm}(X^{(n)}-X^{(n-1)}) < \epsilon)$\\
        then $\gamma^{(n)} = \max \{\gamma_{\mathrm{target}}, k\gamma^{(n-1)}\}$
    \end{enumerate}
    Until $(norm(X^{(n)}-X^{(n-1)} < \epsilon)$ and $(\gamma^{(n)} = \gamma_{\mathrm{target}})$

  \item $ \hat{x} = X^{(n)}$
    где $\alpha$, $\epsilon$, $k$, $\gamma_{\mathrm target}$ экспериментально подобранные параметры алгоритма. 
\end{enumerate}
$$
\mathrm{grad}(x, \gamma) = \frac{1}{\sigma^2} \sum^m_{r=1} W^T_R H^T_r D^T (D H_r W_r x-y_r) + \lambda \cdot G(x, \gamma)
$$
где $\lambda$ экспериментально подобранный регуляризационный параметр и градиент для точки $(i,j)$ задан следующей формулой

$$
\begin{array}{rcl}
 G(i,j) & = & 2\left[x(i,j)-x(i,j-1)\right] \exp\left(-[ x(i,j)-x(i,j-1) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i,j+1)\right] \exp\left(-[ x(i,j)-x(i,j+1) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i+1,j)\right] \exp\left(-[ x(i,j)-x(i-1,j) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i-1,j)\right] \exp\left(-[ x(i,j)-x(i+1,j) ]^2/\gamma \right)
\end{array}
$$


\section{Результаты}
 Выбранные алгоритмы основываются на разном изначальном наборе данных, поэтому объективно сравнить их не представляется
 возможным. Поэтому, при сравнение и выводе о применимости мы руководствуемся следующим:
 \begin{itemize}
   \item Алгоритм из раздела \ref{sr1} использует для повышение изображения одно изображение, поэтому  его можно легко
     сравнить с бикубической интерполяцией.
   \item Алгоритм из раздела \ref{sr2} использует несколько изображений. Поскольку для работы алгоритм считает начальное
     приближение, то его результат можно сравнивать с начальным приближением.
 \end{itemize}

Тестирование алгоритмов осуществлялось на наборе изображений автомобильных номеров (см. рис. \ref{fig:samples}). Стоит
заменить, что конкретно эти изображения не были включены в обучающий набор алгоритма с использованием пары тренированных
словарей.

Для второго алгоритма были проведены опыты по установлению устойчивости алгоритма к ошибкам сдвига (помеха в определении
движения изображений), устойчивости к размытию (см. рис. \ref{fig:blur_lambda}, \ref{fig:warps_noise}).

\begin{figure}[h]
  \begin{center}
    \includegraphics{../presentation/content/out_sr1.png}
  \end{center}
  \caption{Выборка изображений для построения графика для оценки результатов работы алгоритмов по нескольким
  изображениям.}
  \label{fig:samples}
\end{figure}

\begin{figure}[p]
  \centering
  \input{../plots/plot_sr1.tex}
  \caption{Результаты алгоритма с тренированными словарями.  }
  \label{fig:plot_sr1}
\end{figure}

\begin{figure}[p]
  \centering
  \input{../plots/plot_sr2.tex}
  \caption{Результаты работы алгоритма с использование регуляризации. В нашей
    реализации мы использовали $\alpha = 0.07$, $ \epsilon=0.005$, $ k=0.95$, $ \gamma_{\mathrm target}=10$ \label{plot_sr2}}
\end{figure}

\begin{figure}[p]
  \centering
  \includegraphics[width=12cm]{img/blur_lambda.png}
  \caption{ График зависимости повышения PSNR алгоритмом с использованием регуляризации при разных параметрах размытия и
    $lambda$.\label{fig:blur_lambda}}
\end{figure}

\begin{figure}[p]
  \centering
  \includegraphics[width=12cm]{img/warps_noise.png}
  \caption{График зависимости повышения PSNR алгоритмом с использованием регуляризации при аддитивном гауссовском шуме в
    определении сдвигов изображений низкого качества (помехи в установлении движения). \label{fig:warps_noise}}
\end{figure}

\begin{figure}[p]
  \centering
  \input{../plots/sr2_psnr_rising.tex}
  \caption{Пример работы алгоритма с регуляризацией. На графике PSNR хорошо видно, как вырастает PSNR в зависимости
    от шага алгоритма \label{plot_sr2_rising_low}}
\end{figure}

 \begin{figure}[p]
   \centering
   \input{../plots/sr2_psnr_rising_2.tex}
   \caption{Пример изображений алгоритма с регуляризацией для изображения с более высоким исходным разрешением.
     \label{plot_sr2_rising_high}}
 \end{figure}


\subsection{Средства}
Работа по подготовке изображений, построению графиков, реализации алгоритмов была выполнена в среде MatLab. Конвертация
изображений для подготовки базы была выполнена с помощью ImageMagick в оболочке zsh. Выделение изображений автомобильных
номеров было выполнено с использование графического пакета GIMP.
%Полный
%исходный код можно найти по адресу \url{https://github.com/ulex/sr-license-plates}.


% \subsection{Дальнейшее исследование}
% В дальнейшем планируется использовать

\subsection{Вывод} В результате опытов было установлено, что, несмотря на то, что в большинстве случаев первый алгоритм
улучшает PSNR, результаты его работы существенно хуже второго.

Второй алгоритм обладает устойчивостью к следующим шумам в исходных данных:
\begin{itemize}
  \item устройчивость к ошибкам сдвига (ошибка до 0,2 пикселя существенно не меняет результат, ошибка до 2 пикселей
    приводит к повышению PSNR по сравнению с начальным приближением)
  \item устройчисовть к шуму на на исходных изображениях (нормальный шум с дисперсией $\sigma=25$ при значениях яркости
    от 0 до 255)
  \item усточивость к размытию исходных изображений ($\sigma = 1$)
\end{itemize}

%И в нашей модели он хорошо себя характеризует тем, что даже при больших помехах он качественно повышает разрешение изображения.


% Была проделана следующая работа:
% \begin{itemize}
%   \item Исследованы современные подходы к задаче SR.
%   \item Реализован алгоритм повышения разрешения с использованием регуляризации.
%   \item Проведено исследование по качеству восстановления изображение
% \end{itemize}<++>

\newpage
\nocite{*}
\bibliographystyle{plain}
\bibliography{bib}

