\section{Введение}
Цифровое изображение имеет конечное количество пикселей. Количество этих пикселей деленное на единицу площади называется
разрешением цифрового изображения.

Для анализа и обработки изображений в большинстве случаев используются изображения высокого разрешения, так как они
позволяют увидеть детали, которые не различимы, или плохо различимы на изображениях с низким разрешением. Многие задачи
компьютерного зрения изначально полагаются на то, что изображение на входе в хорошем разрешение. Например, алгоритмы
распознавания автомобильного номера будут работать намного устойчивее, если на вход они будут получать изображение с
высоким разрешением. С первого взгляда,
задача увеличения разрешения чисто аппаратная -- чтобы увеличить разрешение необходимо просто взять фотоаппарат с
большей разрешающей способностью. Но часто уже имеется некоторая фотография или набор фотографий, и нет возможности
повторно произвести съемку. Примером может послужить низкокачественные картинки с изображений камер наблюдения. В этом
случае уместно использовать программные алгоритмы повышения разрешения (Super-resolution методы).  Эти алгоритмы
используют некоторое дополнительное знание о изображении для качественного повышения разрешения. Примером
дополнительных знаний может послужить информация о том, как двигался объект во время съемки, или оптические параметры
камеры. Зная эти параметры можно алгоритмическим путем получить более качественное изображение.

В этой работе рассмотрены два алгоритма для повышения разрешения на примере автомобильных номеров.

\section{Обзор существующих алгоритмов} Классические алгоритмы Super-Resolution делятся на четыре
категории\footnote{Стоит заметить, что существуют алгоритмы, которые будут плохо ложиться на эти категории. Но такие
алгоритмы не сыскали большой известности, поэтому из рассмотрения убраны.}.  Существует несколько обзорных статей по
этим алгоритмам \cite{ParkS.C.2003,tian2011survey}

\subsection{Обучаемые алгоритмы}
Обучаемые алгоритмы используют для восстановления изображений используют знание о том, что в действительности изображено
на картинке. Такие алгоритмы хорошо подходят для повышения разрешения однотипных изображений, таких как лица или
автомобильные номера.

\subsection{Интерполяционные} Подход интерполяции наиболее интуитивно понятный метод решения задачи SR. Решение задачи,
в общем случае, разбивается на три шага: определение относительного движения (Motion estimation) для каждого
изображения, интерполяция LR изображений на HR сетку, удаление смазывания и шума для полученного HR изображения.

\subsubsection{Метод ближайшего соседа}
При печати этого текста компьютером тоже была решена задача повышения разрешения, т.к. принтер печатает изображения с
намного более большим разрешением, чем была исходная картинка. В этом случае, задача решается не самым лучшим образом -
компьютер просто просчитывает недостающие точки используя значения пикселя изображения, который находится ближе всего.
Такая примитивная интерполяция называется <<метод ближайшего соседа>>.

\subsubsection{Билинейная интерполяция}
Билинейная интерполяция чуть более продвинутый метод интерполяции. Для интерполяции используется взвешенные суммы
линейных интерполяций по вертикальной и горизонтальной оси. Более подробное описание и формулу билинейной интерполяции
можно найти в \cite[стр. 64]{gonzalez2002woods}.

\subsubsection{Бикубическая интерполяция}
Бикубическая интерполяция обладает одним из лучших сочетаний качества и скорости.  Бикубическая
интерполяция являеется обобщением интерполяции кубическими сплайнами на двумерный случай. Алгоритм кубической
интерполяции реализован во многих редакторах цифровых изображений. В нашей статье мы будем считать алгоритм бикубической
интерполяции отправной точкой. По сравнение результатов бикубической интерполяции и предложенного метода можно судить
том, улучшает алгоритм изображение, или нет. Более подробно алгоритм описан в  \cite{keys1981cubic}.

\subsection{Спектральное представление}
В алгоритмах этого класса используется разложение изображения в некоторый другой
базис (примером может являться двумерное дискретное преобразование Фурье, или дискретное косинусное преобразование), и
обратное к нему.  Этот метод удобен тем, что мелкие детали соответствуют высоко частотным компонентам базиса, и за счет
этого становится возможным восстанавливать мелкие детали изображения, которые возможно получить за счет интерполяции с
нескольких LR изображений.

\subsection{Регуляризация} Алгоритмы с использованием регуляризации используют некоторые знания о природе изображения.
Например, в алгоритме MAP используют предположение о вероятности распределений точек.

\section{Постановка задачи}
Для рассуждений необходимо некоторым образом формально записать то, с чем имеем дело. Для этого понадобиться ввесте
несколько дополнительных понятий.

\subsection{Метрика PSNR}
Для того, чтобы сравнивать несколько алгоритмов повышения разрешения необходимо ввести какую-нибудь количественную
метрику. Чтобы иметь возможность посчитать метрику необходимо знать эталонное изображение, то есть такое изображение,
которое должен выдать идеальный алгоритм повышения разрешения. Очевидно, что создать эталонный алгоритм невозможно --
это отображение из $\mathbb{N}^{n \cdot m } \to \mathbb{N}^{nk \cdot mk}, k \ge 2$. Знание эталонного изображения
несколько выходит за рамки поставленной во введении задачи -- в реальных условиях истинное изображение будет неизвестно.
Для тестирования алгоритмов были использована стандартная модель получения изображений низкого разрешения из высокого.

Пусть $x$ -- истинное изображение, $\tilde{x}$ -- найденное изображение из изображений низкого разрешения. Посчитаем
среднеквадратичную ошибку между пикселями этих изображений.

$$ \mathrm{MSE}(\tilde{x},x) = \frac{1}{m\,n}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1} [\tilde{x}(i,j) - x(i,j)]^2$$

И выразим отношение $\mathrm{MAX}_I$ -- максимальное значение яркости изображения к среднеквадратичной ошибке в
децибелах
$\mathrm{PSNR}(\tilde{x},x)$.
$$ \mathrm{PSNR}(\tilde{x},x) = 10 \cdot \log_{10} \left( \frac{\mathrm{MAX}_I^2}{\mathrm{MSE}(\tilde{x},x)} \right) $$

Это и будет нашей метрикой. Задачей будет достигнуть максимального значения PSNR из имеющихся данных.

\subsection{Интерполяция}
Одним из наиболее известных способов повышения разрешения является интерполяция. Для любого изображения можно бесконечно
повышать разрешения, просто добавляя дополнительные значения между пикселями исходного изображения. Однако, такое
повышение разрешения не всегда дает хорошие результаты. Поскольку значение PSNR лишь показывает разницу между двумя
изображениями, то нет возможности численно оценить насколько алгоритм Super-resolution хорошо справился с задачей. Но
если сравнивать этот же алгоритм со значением полученные каким-либо методом интерполяции то наглядно видно, где алгоритм
справляется хорошо, а где плохо.

\subsection{Изображения как векторы}
Для возможности записывать все операции над изображением как матричное умножение, будем считать, что изображение
высокого разрешения, которое мы хотим восстановить $x$ размера $L_{1}N_{1}\times L_{2}N_{2}$ записано в виде вектора в
виде вектора $x=[x_{1},x_{2},\dots,x_{N}]^{T}$, где $N=L_{1}{N_{1}\times L_{2}N_{2}}$. Другими словами, изображение $x$
это то изображение, которое мы бы получили, если бы использовали матрицу фотоаппарата с более большим разрешением. Мы
будем рассматривать следующую стандартную модель искажения изображения
$$ y_{r} = DB_rM_rx+\sigma_{k}\epsilon $$
где $M_{r}$матрица геометрического преобразования для конкретного изображения $y_{r}$, $ B_{r} $ обозначает матрицу размытия
размером $L_{1}N_{1}L_{2}N_{n}\times L_{1}N_{1}L_{2}N_{2}$, $D$ матрица понижения разрешения размера,
$\sigma_{r}\epsilon$ -- аддитивный шум.

\subsection{Задача Super-Resolution}
$$y_r = D H_r W_r x +\sigma_{k}\epsilon,~ ~ ~ 1 \leq r \leq m$$
 где:
 \begin{itemize}
   \item $x$ оригинальное изображение
   \item $y_r$ наблюдение $r$
   \item $D$ матрица понижение разрешения
   \item $W_r$ матрица геометрического искажения
   \item $H_r$ матрица размытия наблюдения $r$
   \item $\sigma_{k}\epsilon$ шум наблюдения $r$
   \item $m$ количество наблюдений
 \end{itemize}
 Задача найти
 $$ \tilde{x} = \underset{\hat{x}}{\operatorname{argmax}}~  PSNR(\hat{x},x)$$

\section{Используемые алгоритмы}
Для того, чтобы повысить разрешение автомобильного номера использовались два подхода: обучаемый \cite{yang2012coupled} и
интерполяционный с использованием регуляризации \cite{suresh2007superresolution}. Этот выбор основывался исходя из
природы изображения автомобильного номера.

\subsection{Обучаемый алгоритм на словарях}
В статье \cite{yang2012coupled} авторы предлагают использовать для задачи повышения разрешения одного изображения
использовать пару связанных словарей $D_x$ и $D_y$ -- словари содержащие патчи из пространства изображений
с высоким и низким разрешением.

Алгоритм требует предварительного обучения нейронной сети. Для этого была создана база с изображениями автомобильных
номеров. Использовав авторскую реализацию алгоритма была обучена пара словарей для восстановления изображений.

Обоснованием, для применения этого метода были следующие:
\begin{itemize}
  \item Автомобильные номера содержат конечный набор патчей. Автомобильные номера очень похожи между собой. И явно
    видно, что между двумя изображениями автомобильных номеров есть общие кусочки изображения.
  \item Автомобильные номера имеют простую структуру -- у них нет сложных переходов, большиство смены цветов это просто
    переход от белого к черному.
\end{itemize}

\subsection{Алгоритм с использованием регуляризации}
В статье \cite{yuan2008fast} авторы предлагают улучшение алгоритма MAP для задачи повышение изображения. Изображение
моделируется как Марковская сеть и используется алгоритм шаговой оптимизации в сочетании с адаптивным
регуляризатором для сохранения границ.

Прежде, чем говорить о самом алгоритме требуется сделать предварительный шаг -- установление движение (motion
estimation). 

Общий вид алгоритма следующий:
\begin{enumerate}
  %\item Найти целочисленный сдвиг изображений относительно первого. Эта задача решается испол
  \item посчитать среднее от выровненных и билинейно интерполированных изображений $X^{(0)}$. Будем называть полученные на этом
    шаге изображение <<начальным приближением>>
  \item положить $\gamma = 2v$, где $v$ -- максимальное значение градиента по осям $x$ и $y$ в начальном приближении
    $X^{(0)}$
  \item Do:
    \begin{enumerate}
      \item $X^{(n+1)} = X^{(n)} - \alpha\cdot\mathrm{grad}(X^{(N)}, \gamma) $
      \item $n=n+1$
      \item If $(\operatorname{norm}(X^{(n)}-X^{(n-1)}) < \epsilon)$\\
        then $\gamma^{(n)} = \max \{\gamma_{\mathrm{target}}, k\gamma^{(n-1)}\}$
    \end{enumerate}
    Until $(norm(X^{(n)}-X^{(n-1)} < \epsilon)$ and $(\gamma^{(n)} = \gamma_{\mathrm{target}})$

  \item $ \hat{x} = X^{(n)}$
    где $\alpha, \epsilon, k, \gamma{\mathrm target} $ экспериментально подобранные параметры алгоритма. В нашей
    реализации мы использовали $\alpha = 0.07, \epsilon=0.005, k=0.95, \gamma_{\mathrm target}=10$
\end{enumerate}
$$
\mathrm{grad}(x, \gamma) = \frac{1}{\sigma^2} \sum^m_{r=1} W^T_R H^T_r D^T (D H_r W_r x-y_r) + \lambda \cdot G(x, \gamma)
$$
где $\lambda$ экспериментально подобранные регуляризационный параметр и градиент для точки $(i,j)$ задан следующей формулой

$$
\begin{array}{rcl}
 G(i,j) & = & 2\left[x(i,j)-x(i,j-1)\right] \exp\left(-[ x(i,j)-x(i,j-1) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i,j+1)\right] \exp\left(-[ x(i,j)-x(i,j+1) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i+1,j)\right] \exp\left(-[ x(i,j)-x(i-1,j) ]^2/\gamma \right) \\
& + & 2\left[x(i,j)-x(i-1,j)\right] \exp\left(-[ x(i,j)-x(i+1,j) ]^2/\gamma \right)
\end{array}
$$


\section{Результаты}

\subsection{Обучаемый алгоритм на словарях}
графики сравнения PSNR скорость работы примеры изображений

\subsection{Алгоритм с использованием регуляризации }
графики сравнения PSNR скорость работы примеры изображений

сравнение с билинейной/бикубической интерполяцией

\section{Заключение}

\subsection{какие средства использовались}

\subsection{что было сделано}

\subsection{Дальнейшее исследование}

\subsubsection{исследование других подходов}

\subsubsection{автоматическое детектирование}

\newpage
\nocite{*}
\bibliographystyle{unsrt}
\bibliography{bib}

